#include <stdio.h>
#include <ctype.h>
/*
Номера букв русского алфавита в целом типе (сначала алфавит строчных, потом заглавных)
-80а
-79б
-78в
-77г
-76д
-75е
-111ё
-74ж
-73з
-72и
-71й
-70к
-69л
-68м
-67н
-66о
-65п
-128р
-127с
-126т
-125у
-124ф
-123х
-122ц
-121ч
-120ш
-119щ
-118ъ
-117ы
-116ь
-115э
-114ю
-113я
-112А
-111Б
-110В
-109Г
-108Д
-107Е
-127Ё
-106Ж
-105З
-104И
-103Й
-102К
-101Л
-100М
-99Н
-98О
-97П
-96Р
-95С
-94Т
-93У
-92Ф
-91Х
-90Ц
-89Ч
-88Ш
-87Щ
-86Ъ
-85Ы
-84Ь
-83Э
-82Ю
-81Я
*/
int to_index(int a) {
	if (a == -79 || a == -111) return 0;
	if (a == -78 || a == -110) return 1;
	if (a == -77 || a == -109) return 2;
	if (a == -76 || a == -108) return 3;
	if (a == -74 || a == -106) return 4;
	if (a == -73 || a == -105) return 5; // c
	if (a == -71 || a == -103) return 6;
	if (a == -70 || a == -102) return 7;
	if (a == -69 || a == -101) return 8;
	if (a == -68 || a == -100) return 9;
	if (a == -67 || a == -99) return 10;
	if (a == -65 || a == -97) return 11;
	if (a == -128 || a == -96) return 12;
	if (a == -127 || a == -95) return 13; // Z
	if (a == -126 || a == -94) return 14;
	if (a == -124 || a == -92) return 15;
	if (a == -123 || a == -91) return 16;
	if (a == -122 || a == -90) return 17; // ce
	if (a == -121 || a == -89) return 18;
	if (a == -120 || a == -88) return 19;
	if (a == -119 || a == -87) return 20;
	return 21;
}

// Проверка, на то, русская ли это буква
int rus_let(int a) {
	if (a <= -65 && a >= -128) return 1;
	return 0;
}

//Множество, состоящее только из гласных букв русского алфавита. Реализованно, как число, в котором 1 и 0 на i-ом индексе (справа, нумерация с 1) в двоичном представлении числа означают, что буква с i-ым номером по алфавиту присутствует или же отсутствует соответственно.
#define SVIST (1u<<(5) | 1u<<(13) | 1u<<(17))
#define CONSONANTS (1u<<(0) | 1u<<(1) | 1u<<(2) | 1u<<(3) | 1u<<(4) | 1u<<(5) | 1u<<(6) | 1u<<(7) | 1u<<(8) | 1u<<(9) | 1u<<(10) | 1u<<(11) | 1u<<(12) | 1u<<(13) | 1u<<(14) | 1u<<(15) | 1u<<(16) | 1u<<(17) | 1u<<(18) | 1u<<(19) | 1u<<(20))
int main() {

	// с - текущий символ, который считываем; w - множество, из гласных букв текущего слова; num - номер по алфавиту текущего слова; in_word - ключ, проверяющуй, находимся ли мы в слове; c1 - 	целочисленное представление буквы;
	char c;
	int c1;
	unsigned int w = 0, num, in_word = 0;
	// Открытие файлов
	FILE *file = fopen("data.txt", "r");
	
	
	// Считывание файла
	while ( (c = getc(file)) != EOF ){
		c1 = (int) c;
		
		
		// Если не буква и не пробел, пропускаем
		if (!(rus_let(c1) || isspace(c))) {
			continue;
		}
		
		
		// Если сейчас мы не в слове и текущий символ - буква, то мы заходим в слово.
		if (in_word == 0 && rus_let(c1)) {
			//printf("%d\n", c1);
			in_word = 1;
			w = 0;
			
		}
		
		// Если мы были в слове и текущий символ - пробельный, то мы выходим из слова и проверяем, если множество согласных текущего слова равно множеству свистящих согласных и есть хотя бы 			одна такая согласная, то выводим успешный ответ и завершаем программу.
		
		if (in_word && isspace(c)) {
			if ( (w | SVIST) == SVIST && w) {
				printf("В файле есть слово, все согласные которого свистящие\n");
				return 0;
			}
			in_word = 0;
			w = 0;
			continue;
		}
		
		// Если мы находимся в слове, проверяем, является ли буква согласной. Если она согласная, то добавляем в множество согласных букв текущего слова
		if (in_word) {
			num = 1u<<(to_index(c1));
			

			if ( (num | CONSONANTS) == CONSONANTS) {
				w |= num;
			}
		}
		
		
		
		
	}
	// Если ответ об успешном завершении программы не был выведен, значит не было подходящих слов
	printf("В файле отсутствуют слова, в которых все согласные свистящие\n");
	
	// Закрытие файлов
	fclose(file);
}