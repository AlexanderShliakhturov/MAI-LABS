#include <stdio.h>
#include <math.h>

// Функция, данная в задании
long double func ( long double x ) { 
	return expl(x) - expl(-x) - 2; 
}

// Производная функции, данной в задании
long double dif_func (long double x) {
	return expl(x) + expl(-x);
}

// Вторая производная функции, данной в задании
long double dif_dif_func (long double x) {
	return expl(x) - expl(-x);
}

// Функция модуль
long double my_abs( long double x) {
	if ( x < 0 ) {
		return -x;
	}
	return x;
}

int main() {
    //eps - машинное эпсилон (очень маленькое число); a - левая граница отрезка; b - правая граница отрезка; x - текущие промежуточное значение корня; x1 - предыдущие промежуточное значение корня
    long double eps = 1.0l, a = 0.0l, b = 1.0l, x, x1 = 0;
    
    // Вычисление машинного эпсилона
    while (1.0l + eps / 2.0l > 1.0l) { 
    	eps /= 2.0l;
    }
    
    printf("Машинное эпсилон для типа double = %.16Le\n", eps);
    
    // Проверка на сходимость
    // Для этого проходимся циклом от левой границе к правой, с шагом 1/1000000, проверяя, выполнение условие сходимости |F(x) * F''(x)| < (F'(x))^2, если условие не выполнятеся, мы завершаем программу
    for (long long i = 0; i <= 1000000; i++ ) {
    	x = i / 1000000.0l;
    	if (my_abs(func(x) * dif_dif_func(x)) - dif_func(x) * dif_func(x) >= eps) {
    		printf("Невозможно вычислить значение методом Ньютона, метод не сходится.\n");
    		return 0;
    	}
    }
    
    // Изначально, х равен середине отрезка
    x = (a + b) / 2;
    
    // Само вычисление корня
    while (my_abs(x - x1) >= eps) {
    	x1 = x;
    	x = x1 - func(x) / dif_func(x);
    }
	
	// Вывод ответа
	printf("Приближенное значение корня, полученного при помощи метода Ньютона равно: %Le\n", x);
}